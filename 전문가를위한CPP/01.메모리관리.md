책264p - 269p
---

### 메모리관리

:pushpin: **CAUTION** : 요즘은 C++에서 로우레벨 메모리연산은 가급적 피하고 컨테이너나 스마트 포인터와 같은 최신 기능을 활용하는 추세이다 예를들어 C스타일 배열을 동적으로 할당하지 않고 표준라이브러리에서 제공하는 vector처럼 메모리를 알아서 관리해주는 컨테이너를 이용하는 편이다 포인터도 기존에 사용하던 일반 포인터대신 더 이상사용하지 않으면 알아서 메모리를 해제해주는 스마트 포인터를 사용한다

# :pushpin: 동적 메모리 다루기
## :pushpin: 메모리의 작동과정 살펴보기
```cpp
int i = 7;
``` 
로컬변수 i는 스택에 저장된다 유효범위 벗어나면 할당된 메모리 자동으로 해제

```cpp
int *ptr = nullptr;
ptr = new int;
```
new 키워드를 사용하면 힙 메모리에 할당된다 **:star:변수 ptr은 여전히 스택에 있지만 이 변수가 가리키는 값은 힙영역에 있다:star:**

## :pushpin: 메모리 할당과 해제
## new와 delete의 사용법
new의 리턴값을 무시하거나 그 포인터를 담았던 변수가 스코프를 벗어나면 할당했던 메모리에 **접근할 수 없다** <- **메모리누수**

```cpp
void leaky(){
    new int; //메모리 누수 발생!
    cout << "방금 int하나를 잃어버렸다." << endl;
}
```

힙메모리를 해제하려면 delete키워드에 해제할 메모리를 가리키는 포인터를 지정한다
```cpp
int *ptr = new int;

delete(ptr);
ptr = nullptr;
```

:pushpin: **CAUTION** : new로 메모리를 할당할 때 스마트 포인터가 아닌 일반 포인터로 지정했다면 반드시 그 메모리를 해제하는 delete문을 new와 짝이 되도록 작성

:pushpin: **NOTE** : 메모리를 해제한 포인터는 nullptr로 다시 초기화 그래야 이미 해제된 메모리를 가리키는 포인터를 모르고 다시 사용하는 실수 방지함

## malloc()
C에서는 malloc()은 지정한 바이트 수만큼 메모리를 할당한다 C++도 여전히 malloc()을 지원하지만 new를 사용하는 것이 바람직하다 new는 메모리 할당에서 더 나아가 객체까지 만들기 때문이다

```cpp
Foo *myfoo = (Foo*)malloc(sizeof(Foo));

Foo *myOtherfoo = new Foo();
```
malloc()은 일정한 데이터크기의 메모리 공간만 힙영역에 할당, new()는 메모리할당 + 생성자호출로 객체를 생성

free()도 객체 소멸자를 호출하지 않지만, delete는 소멸자를 호출하여 객체를 정상적으로 제거함

:star: C++에서는 malloc()과 free() 대신 new와 delete를 사용

## 메모리 할당에 실패한 경우
기본적으로 new()가 실패하면 프로그램이 종료된다 프로그램을 작성할떄는 항상 메모리가 부족한 상황에 대비해야한다

메모리실패시 nullptr 리턴하도록

```cpp
int *ptr = new(nothrow) int;
```